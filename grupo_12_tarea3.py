# -*- coding: utf-8 -*-
"""GRUPO_12_Tarea3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GDzG-K0QRleIc0wUDdec-t29S7fCtmn6
"""

#1. Probabilidad de obtener exactamente 7 caras en 10 lanzamientos
#Usamos la función binom.pmf porque tenemos una situación que tiene dos resultados posibles además de que se repetirá cierto número de veces
from scipy.stats import binom
n = 10
k = 7
p = 0.5
probabilidad = binom.pmf(k, n, p)
probabilidad

#2.Calcula la probabilidad acumulada de obtener 7 o menos caras en 10 lanzamientos
#La función binom.cdf nos permitirá calcular esa probabilidad acumulada
from scipy.stats import binom
n = 10
k = 7
p = 0.5
probabilidad_acum = binom.cdf(k, n, p)
probabilidad_acum

#3. Grafica la distribución binomial completa para los 10 lanzamientos, mostrando la probabilidad de obtener desde 0 hasta 10 caras.
import matplotlib.pyplot as plt
import numpy as np

# Definimos los parámetros
n = 10  # número de lanzamientos
p = 0.5 # probabilidad de éxito

# Valores posibles de caras (de 0 a 10), np.arrange(a,b) nos dará un vector que comienza en a y termina en b-1
val_posibles = np.arange(0, n+1)

# Calculamos las probabilidades usando la función binom.pmf
probabilidades = binom.pmf(val_posibles, n, p)

# Graficamos la distribución binomial
plt.bar(val_posibles, probabilidades, color='#00008B') #generamos un gráfico de barras con los datos de la distribución normal
plt.title('Distribución Binomial de 10 Lanzamientos de una Moneda') #título del gráfico
plt.xlabel('Número de Caras') #nombre del eje x
plt.ylabel('Probabilidad') #nombre del eje y
plt.xticks(val_posibles) #valores que aparecerán en el eje x
plt.grid(axis='y', linestyle='--', alpha=0.7) #colocamos un grid en el gráfico y le damos formato
plt.show()

#4. Ahora la moneda tiene mayor probabilidad de caer en cara (probabilidad de éxito 𝒑 =𝟎. 𝟖). ¿Cómo cambian los resultados?
#Vuelve a realizar los ejercicios I, II y III.
#4.1 Calculamos la probabilidad de obtener exactamente 7 caras en 10 lanzamientos, pero con p=0.8
from scipy.stats import binom
n = 10
k = 7
p = 0.8
probabilidadmod = binom.pmf(k, n, p)
probabilidadmod

#4.2Calcula la probabilidad acumulada de obtener 7 o menos caras en 10 lanzamientos con p=0.8
from scipy.stats import binom
n = 10
k = 7
p = 0.8
probabilidad_acum2 = binom.cdf(k, n, p)
probabilidad_acum2

#4.3 Grafica la distribución binomial completa para los 10 lanzamientos, mostrando la probabilidad de obtener desde 0 hasta 10 caras.
import matplotlib.pyplot as plt
import numpy as np

# Definimos los parámetros
n = 10  # número de lanzamientos
p = 0.8 # probabilidad de éxito

# Valores posibles de caras (de 0 a 10), np.arrange(a,b) nos dará un vector que comienza en a y termina en b-1
val_posibles2 = np.arange(0, n+1)

# Calculamos las probabilidades usando la función binom.pmf
probabilidades2 = binom.pmf(val_posibles, n, p)

# Graficamos la distribución binomial
plt.bar(val_posibles2, probabilidades2, color='#00008B') #generamos un gráfico de barras con los datos de la distribución normal
plt.title('Distribución Binomial de 10 Lanzamientos de una Moneda') #título del gráfico
plt.xlabel('Número de Caras') #nombre del eje x
plt.ylabel('Probabilidad') #nombre del eje y
plt.xticks(val_posibles2) #valores que aparecerán en el eje x
plt.grid(axis='y', linestyle='--', alpha=0.7) #colocamos un grid en el gráfico y le damos formato

plt.show()

#5. Utilizando 𝒔𝒄𝒊𝒑𝒚. 𝒔𝒕𝒂𝒕𝒔, realiza un análisis de una distribución normal con una media de 0 y desviación estándar de 1. Genera un conjunto de datos aleatorios con 1000
#muestras a partir de esta distribución.
import numpy as np
import scipy.stats as stats
import matplotlib.pyplot as plt

#Asignamos los valores de los parámetros de la distribución normal
media = 0
dev = 1 #desviación estándar
nro_muestras = 1000

#generamos los datos aleatoriamente como nos pide el enunciado
datos = np.random.normal(media, dev, nro_muestras)

print(datos[:100])

#6. Calcula y muestra la media, la desviación estándar y la mediana de los datos generados
media_muestral = np.mean(datos)
dev_estandar_muestral = np.std(datos)
mediana_muestral = np.median(datos)

media_muestral, dev_estandar_muestral, mediana_muestral

#7. Grafica el histograma de los datos y superpón la curva de la distribución normal teórica.

# Graficamos el histograma de los datos generados
plt.hist(datos, bins=30, density=True, alpha=0.6, color='g', edgecolor='black')

# Establecemos valores para x en la distribución normal teórica
x = np.linspace(min(datos), max(datos), 100)

# Calcular la densidad de la distribución normal teórica
pdf = stats.norm.pdf(x, media, dev) #recordemos que media = 0 y dev = 1

# Graficamos la distribución normal teórica
plt.plot(x, pdf, 'k', linewidth=2)
plt.title('Datos generados y curva de la distribución normal teórica')
plt.xlabel('Valor')
plt.ylabel('Densidad')
plt.show()

#8. Calcula la probabilidad de que un valor caiga dentro del rango de -1 a 1 (una desviación estándar de la media)
#Para calcular la probabilidad necesitamos hallar la función de distribución acumulativa (CDF) para obtener la diferencia entre las funciones que se asignen a 1 y -1
import scipy.stats as stats

prob1= stats.norm.cdf(1, loc=media, scale=dev)
prob2= stats.norm.cdf(-1, loc=media, scale=dev)

probabilidad8 = prob1-prob2
probabilidad8

